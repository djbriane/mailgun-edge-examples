---
description: Rules for Vercel Edge Functions examples under vercel/
globs: ["vercel/**"]
alwaysApply: true
---

# Platform: Vercel Edge Functions

Runtime: **Edge Runtime** (V8 isolates) with Web-standard APIs

## File Structure

Follow this pattern for all examples:

```
vercel/
├── example-name/
│   ├── api/
│   │   └── route.ts         # Edge function (Next.js App Router)
│   ├── package.json
│   ├── tsconfig.json
│   └── README.md
```

## Edge Function Format

Use Next.js App Router with edge runtime:

```typescript
export const runtime = 'edge'
export const dynamic = 'force-dynamic'

export async function POST(request: Request) {
  try {
    // 1. Parse request
    const { param } = await request.json()

    // 2. Get API credentials
    const apiKey = process.env.API_KEY
    if (!apiKey) {
      throw new Error('API_KEY not configured')
    }

    // 3. Call external API
    const response = await fetch('https://api.example.com/endpoint', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
      },
      body: JSON.stringify({ param }),
    })

    if (!response.ok) {
      throw new Error(`API error: ${response.statusText}`)
    }

    const data = await response.json()

    // 4. Return result
    return new Response(
      JSON.stringify(data),
      {
        status: 200,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
        },
      },
    )
  } catch (error) {
    return new Response(
      JSON.stringify({ error: error.message }),
      {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      },
    )
  }
}

// Handle CORS preflight
export async function OPTIONS(request: Request) {
  return new Response(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'content-type, authorization',
    },
  })
}
```

## Environment Variables

Access via `process.env`:

```typescript
const apiKey = process.env.MAILGUN_API_KEY
const domain = process.env.MAILGUN_DOMAIN
```

Set locally in `.env.local`:
```bash
MAILGUN_API_KEY=key-xxxxx
MAILGUN_DOMAIN=mg.example.com
```

Deploy secrets via Vercel Dashboard or CLI:
```bash
vercel env add MAILGUN_API_KEY
```

**Never commit `.env.local` to git!**

## Configuration Files

### package.json
```json
{
  "name": "example-name",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.0.0",
    "react-dom": "^18.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@types/react": "^18.0.0",
    "typescript": "^5.0.0"
  }
}
```

### next.config.js (optional)
```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
  // Edge runtime configuration
}

module.exports = nextConfig
```

## CORS Handling

Handle via HTTP methods:

```typescript
export async function OPTIONS(request: Request) {
  return new Response(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'content-type, authorization',
    },
  })
}
```

Add CORS headers to all responses:
```typescript
headers: {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
}
```

## README Template

```markdown
# Function Name

Brief description of what this does.

## External API

- **Service**: [API Name](https://docs-url.com)
- **Endpoint**: `POST /v1/endpoint`
- **What it does**: One sentence

## Setup

1. Get API key from [Service Dashboard](https://example.com)

2. Install dependencies:
   ```bash
   npm install
   ```

3. Set environment variables in `.env.local`:
   ```bash
   API_KEY=your_key_here
   ```

4. Deploy to Vercel:
   ```bash
   vercel deploy
   ```

## Usage

```bash
curl -X POST 'https://your-project.vercel.app/api/function-name' \
  -H 'Content-Type: application/json' \
  -d '{
    "param": "value"
  }'
```

## Response

```json
{
  "result": "success"
}
```

## Local Development

```bash
npm run dev
# Function available at http://localhost:3000/api/function-name
```
```

## Testing Locally

```bash
# Start dev server
npm run dev

# Test in another terminal
curl -X POST 'http://localhost:3000/api/function-name' \
  -H 'Content-Type: application/json' \
  -d '{"test": "data"}'
```

## Common Patterns

### FormData for APIs that require it:

```typescript
const formData = new FormData()
formData.append('from', 'sender@example.com')
formData.append('to', 'recipient@example.com')
formData.append('subject', 'Hello')
formData.append('text', 'Message body')

const response = await fetch(
  `https://api.mailgun.net/v3/${process.env.MAILGUN_DOMAIN}/messages`,
  {
    method: 'POST',
    headers: {
      'Authorization': `Basic ${btoa(`api:${process.env.MAILGUN_API_KEY}`)}`,
    },
    body: formData,
  }
)
```

### Handle different HTTP methods:

```typescript
export async function GET(request: Request) {
  const { searchParams } = new URL(request.url)
  const email = searchParams.get('email')
  // Handle GET
}

export async function POST(request: Request) {
  const body = await request.json()
  // Handle POST
}
```

### Streaming responses:

```typescript
export const runtime = 'edge'

export async function GET() {
  const encoder = new TextEncoder()

  const stream = new ReadableStream({
    async start(controller) {
      controller.enqueue(encoder.encode('data: hello\n\n'))
      controller.enqueue(encoder.encode('data: world\n\n'))
      controller.close()
    },
  })

  return new Response(stream, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
    },
  })
}
```

## What NOT to Include

- Node.js-specific APIs (unless absolutely necessary)
- Heavy npm packages (keep bundles under 1-2MB)
- Database queries (use serverless functions instead)
- Long-running operations (25s limit)

## Platform-Specific Features

### Edge Config (optional for feature flags):

```typescript
import { get } from '@vercel/edge-config'

export const runtime = 'edge'

export async function GET() {
  const featureEnabled = await get('feature_flag')
  return Response.json({ enabled: featureEnabled })
}
```

## When Creating New Examples

1. Check `specs/` for requirements
2. Create folder: `vercel/example-name/api/`
3. Copy template above into `route.ts`
4. Create minimal `package.json`
5. Implement the specific API integration
6. Create README with complete documentation
7. Test locally with `npm run dev`
8. Keep it simple - one API call, clear pattern

## Deployment

```bash
# Deploy to production
vercel deploy --prod

# Deploy preview
vercel deploy
```

## Size Limits

- Hobby: 1MB after gzip
- Pro: 2MB after gzip  
- Enterprise: 4MB after gzip

Keep examples minimal to work on all tiers.
